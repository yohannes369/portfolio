{"ast":null,"code":"import { Vector3, Color, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Matrix4, Box3, Sphere, BufferAttribute, Vector2, Object3D } from \"three\";\nconst _m1 = /* @__PURE__ */new Matrix4();\nconst _obj = /* @__PURE__ */new Object3D();\nconst _offset = /* @__PURE__ */new Vector3();\nconst Geometry = /* @__PURE__ */(() => {\n  class Geometry2 extends EventDispatcher {\n    static createBufferGeometryFromObject(object) {\n      let buffergeometry = new BufferGeometry();\n      const geometry = object.geometry;\n      if (object.isPoints || object.isLine) {\n        const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n        const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n        buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n        buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n          const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n          buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n        }\n        if (geometry.boundingSphere !== null) {\n          buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n          buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n      } else if (object.isMesh) {\n        buffergeometry = geometry.toBufferGeometry();\n      }\n      return buffergeometry;\n    }\n    constructor() {\n      super();\n      this.isGeometry = true;\n      this.uuid = MathUtils.generateUUID();\n      this.name = \"\";\n      this.type = \"Geometry\";\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.elementsNeedUpdate = false;\n      this.verticesNeedUpdate = false;\n      this.uvsNeedUpdate = false;\n      this.normalsNeedUpdate = false;\n      this.colorsNeedUpdate = false;\n      this.lineDistancesNeedUpdate = false;\n      this.groupsNeedUpdate = false;\n    }\n    applyMatrix4(matrix) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      for (let i = 0, il = this.vertices.length; i < il; i++) {\n        const vertex = this.vertices[i];\n        vertex.applyMatrix4(matrix);\n      }\n      for (let i = 0, il = this.faces.length; i < il; i++) {\n        const face = this.faces[i];\n        face.normal.applyMatrix3(normalMatrix).normalize();\n        for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n        }\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x, y, z) {\n      _m1.makeTranslation(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x, y, z) {\n      _m1.makeScale(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    fromBufferGeometry(geometry) {\n      const scope = this;\n      const index = geometry.index !== null ? geometry.index : void 0;\n      const attributes = geometry.attributes;\n      if (attributes.position === void 0) {\n        console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n        return this;\n      }\n      const position = attributes.position;\n      const normal = attributes.normal;\n      const color = attributes.color;\n      const uv = attributes.uv;\n      const uv2 = attributes.uv2;\n      if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n      for (let i = 0; i < position.count; i++) {\n        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n        if (color !== void 0) {\n          scope.colors.push(new Color().fromBufferAttribute(color, i));\n        }\n      }\n      function addFace(a, b, c, materialIndex) {\n        const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n        const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n        const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n        scope.faces.push(face);\n        if (uv !== void 0) {\n          scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n        }\n        if (uv2 !== void 0) {\n          scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n        }\n      }\n      const groups = geometry.groups;\n      if (groups.length > 0) {\n        for (let i = 0; i < groups.length; i++) {\n          const group = groups[i];\n          const start = group.start;\n          const count = group.count;\n          for (let j = start, jl = start + count; j < jl; j += 3) {\n            if (index !== void 0) {\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n            } else {\n              addFace(j, j + 1, j + 2, group.materialIndex);\n            }\n          }\n        }\n      } else {\n        if (index !== void 0) {\n          for (let i = 0; i < index.count; i += 3) {\n            addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n          }\n        } else {\n          for (let i = 0; i < position.count; i += 3) {\n            addFace(i, i + 1, i + 2);\n          }\n        }\n      }\n      this.computeFaceNormals();\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    normalize() {\n      this.computeBoundingSphere();\n      const center = this.boundingSphere.center;\n      const radius = this.boundingSphere.radius;\n      const s = radius === 0 ? 1 : 1 / radius;\n      const matrix = new Matrix4();\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n      this.applyMatrix4(matrix);\n      return this;\n    }\n    computeFaceNormals() {\n      const cb = new Vector3(),\n        ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n      }\n    }\n    computeVertexNormals(areaWeighted = true) {\n      const vertices = new Array(this.vertices.length);\n      for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v] = new Vector3();\n      }\n      if (areaWeighted) {\n        const cb = new Vector3(),\n          ab = new Vector3();\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const face = this.faces[f];\n          const vA = this.vertices[face.a];\n          const vB = this.vertices[face.b];\n          const vC = this.vertices[face.c];\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          vertices[face.a].add(cb);\n          vertices[face.b].add(cb);\n          vertices[face.c].add(cb);\n        }\n      } else {\n        this.computeFaceNormals();\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const face = this.faces[f];\n          vertices[face.a].add(face.normal);\n          vertices[face.b].add(face.normal);\n          vertices[face.c].add(face.normal);\n        }\n      }\n      for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v].normalize();\n      }\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(vertices[face.a]);\n          vertexNormals[1].copy(vertices[face.b]);\n          vertexNormals[2].copy(vertices[face.c]);\n        } else {\n          vertexNormals[0] = vertices[face.a].clone();\n          vertexNormals[1] = vertices[face.b].clone();\n          vertexNormals[2] = vertices[face.c].clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n    computeFlatVertexNormals() {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(face.normal);\n          vertexNormals[1].copy(face.normal);\n          vertexNormals[2].copy(face.normal);\n        } else {\n          vertexNormals[0] = face.normal.clone();\n          vertexNormals[1] = face.normal.clone();\n          vertexNormals[2] = face.normal.clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n    computeMorphNormals() {\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        if (!face.__originalFaceNormal) {\n          face.__originalFaceNormal = face.normal.clone();\n        } else {\n          face.__originalFaceNormal.copy(face.normal);\n        }\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n        for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n          if (!face.__originalVertexNormals[i]) {\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n          } else {\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n          }\n        }\n      }\n      const tmpGeo = new Geometry2();\n      tmpGeo.faces = this.faces;\n      for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n        if (!this.morphNormals[i]) {\n          this.morphNormals[i] = {};\n          this.morphNormals[i].faceNormals = [];\n          this.morphNormals[i].vertexNormals = [];\n          const dstNormalsFace = this.morphNormals[i].faceNormals;\n          const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n          for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const faceNormal = new Vector3();\n            const vertexNormals = {\n              a: new Vector3(),\n              b: new Vector3(),\n              c: new Vector3()\n            };\n            dstNormalsFace.push(faceNormal);\n            dstNormalsVertex.push(vertexNormals);\n          }\n        }\n        const morphNormals = this.morphNormals[i];\n        tmpGeo.vertices = this.morphTargets[i].vertices;\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals();\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const face = this.faces[f];\n          const faceNormal = morphNormals.faceNormals[f];\n          const vertexNormals = morphNormals.vertexNormals[f];\n          faceNormal.copy(face.normal);\n          vertexNormals.a.copy(face.vertexNormals[0]);\n          vertexNormals.b.copy(face.vertexNormals[1]);\n          vertexNormals.c.copy(face.vertexNormals[2]);\n        }\n      }\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        face.normal = face.__originalFaceNormal;\n        face.vertexNormals = face.__originalVertexNormals;\n      }\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      this.boundingBox.setFromPoints(this.vertices);\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      this.boundingSphere.setFromPoints(this.vertices);\n    }\n    merge(geometry, matrix, materialIndexOffset = 0) {\n      if (!(geometry && geometry.isGeometry)) {\n        console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n        return;\n      }\n      let normalMatrix;\n      const vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n      if (matrix !== void 0) {\n        normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      }\n      for (let i = 0, il = vertices2.length; i < il; i++) {\n        const vertex = vertices2[i];\n        const vertexCopy = vertex.clone();\n        if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n        vertices1.push(vertexCopy);\n      }\n      for (let i = 0, il = colors2.length; i < il; i++) {\n        colors1.push(colors2[i].clone());\n      }\n      for (let i = 0, il = faces2.length; i < il; i++) {\n        const face = faces2[i];\n        let normal, color;\n        const faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n        const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n        faceCopy.normal.copy(face.normal);\n        if (normalMatrix !== void 0) {\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n        }\n        for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n          normal = faceVertexNormals[j].clone();\n          if (normalMatrix !== void 0) {\n            normal.applyMatrix3(normalMatrix).normalize();\n          }\n          faceCopy.vertexNormals.push(normal);\n        }\n        faceCopy.color.copy(face.color);\n        for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n          color = faceVertexColors[j];\n          faceCopy.vertexColors.push(color.clone());\n        }\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n        faces1.push(faceCopy);\n      }\n      for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n        const faceVertexUvs2 = geometry.faceVertexUvs[i];\n        if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];\n        for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n          const uvs2 = faceVertexUvs2[j],\n            uvsCopy = [];\n          for (let k = 0, kl = uvs2.length; k < kl; k++) {\n            uvsCopy.push(uvs2[k].clone());\n          }\n          this.faceVertexUvs[i].push(uvsCopy);\n        }\n      }\n    }\n    mergeMesh(mesh) {\n      if (!(mesh && mesh.isMesh)) {\n        console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n        return;\n      }\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n      this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    mergeVertices(precisionPoints = 4) {\n      const verticesMap = {};\n      const unique = [],\n        changes = [];\n      const precision = Math.pow(10, precisionPoints);\n      for (let i = 0, il = this.vertices.length; i < il; i++) {\n        const v = this.vertices[i];\n        const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n        if (verticesMap[key] === void 0) {\n          verticesMap[key] = i;\n          unique.push(this.vertices[i]);\n          changes[i] = unique.length - 1;\n        } else {\n          changes[i] = changes[verticesMap[key]];\n        }\n      }\n      const faceIndicesToRemove = [];\n      for (let i = 0, il = this.faces.length; i < il; i++) {\n        const face = this.faces[i];\n        face.a = changes[face.a];\n        face.b = changes[face.b];\n        face.c = changes[face.c];\n        const indices = [face.a, face.b, face.c];\n        for (let n = 0; n < 3; n++) {\n          if (indices[n] === indices[(n + 1) % 3]) {\n            faceIndicesToRemove.push(i);\n            break;\n          }\n        }\n      }\n      for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n        const idx = faceIndicesToRemove[i];\n        this.faces.splice(idx, 1);\n        for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n          this.faceVertexUvs[j].splice(idx, 1);\n        }\n      }\n      const diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n    }\n    setFromPoints(points) {\n      this.vertices = [];\n      for (let i = 0, l = points.length; i < l; i++) {\n        const point = points[i];\n        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n      }\n      return this;\n    }\n    sortFacesByMaterialIndex() {\n      const faces = this.faces;\n      const length = faces.length;\n      for (let i = 0; i < length; i++) {\n        faces[i]._id = i;\n      }\n      function materialIndexSort(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n      faces.sort(materialIndexSort);\n      const uvs1 = this.faceVertexUvs[0];\n      const uvs2 = this.faceVertexUvs[1];\n      let newUvs1, newUvs2;\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\n      for (let i = 0; i < length; i++) {\n        const id = faces[i]._id;\n        if (newUvs1) newUvs1.push(uvs1[id]);\n        if (newUvs2) newUvs2.push(uvs2[id]);\n      }\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.5,\n          type: \"Geometry\",\n          generator: \"Geometry.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (let key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      const vertices = [];\n      for (let i = 0; i < this.vertices.length; i++) {\n        const vertex = this.vertices[i];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n      const faces = [];\n      const normals = [];\n      const normalsHash = {};\n      const colors = [];\n      const colorsHash = {};\n      const uvs = [];\n      const uvsHash = {};\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        const hasMaterial = true;\n        const hasFaceUv = false;\n        const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n        const hasFaceNormal = face.normal.length() > 0;\n        const hasFaceVertexNormal = face.vertexNormals.length > 0;\n        const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        const hasFaceVertexColor = face.vertexColors.length > 0;\n        let faceType = 0;\n        faceType = setBit(faceType, 0, 0);\n        faceType = setBit(faceType, 1, hasMaterial);\n        faceType = setBit(faceType, 2, hasFaceUv);\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\n        faceType = setBit(faceType, 4, hasFaceNormal);\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\n        faceType = setBit(faceType, 6, hasFaceColor);\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\n        faces.push(faceType);\n        faces.push(face.a, face.b, face.c);\n        faces.push(face.materialIndex);\n        if (hasFaceVertexUv) {\n          const faceVertexUvs = this.faceVertexUvs[0][i];\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n        }\n        if (hasFaceNormal) {\n          faces.push(getNormalIndex(face.normal));\n        }\n        if (hasFaceVertexNormal) {\n          const vertexNormals = face.vertexNormals;\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n        }\n        if (hasFaceColor) {\n          faces.push(getColorIndex(face.color));\n        }\n        if (hasFaceVertexColor) {\n          const vertexColors = face.vertexColors;\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n        }\n      }\n      function setBit(value, position, enabled) {\n        return enabled ? value | 1 << position : value & ~(1 << position);\n      }\n      function getNormalIndex(normal) {\n        const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        if (normalsHash[hash] !== void 0) {\n          return normalsHash[hash];\n        }\n        normalsHash[hash] = normals.length / 3;\n        normals.push(normal.x, normal.y, normal.z);\n        return normalsHash[hash];\n      }\n      function getColorIndex(color) {\n        const hash = color.r.toString() + color.g.toString() + color.b.toString();\n        if (colorsHash[hash] !== void 0) {\n          return colorsHash[hash];\n        }\n        colorsHash[hash] = colors.length;\n        colors.push(color.getHex());\n        return colorsHash[hash];\n      }\n      function getUvIndex(uv) {\n        const hash = uv.x.toString() + uv.y.toString();\n        if (uvsHash[hash] !== void 0) {\n          return uvsHash[hash];\n        }\n        uvsHash[hash] = uvs.length / 2;\n        uvs.push(uv.x, uv.y);\n        return uvsHash[hash];\n      }\n      data.data = {};\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if (colors.length > 0) data.data.colors = colors;\n      if (uvs.length > 0) data.data.uvs = [uvs];\n      data.data.faces = faces;\n      return data;\n    }\n    clone() {\n      return new Geometry2().copy(this);\n    }\n    copy(source) {\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.name = source.name;\n      const vertices = source.vertices;\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.vertices.push(vertices[i].clone());\n      }\n      const colors = source.colors;\n      for (let i = 0, il = colors.length; i < il; i++) {\n        this.colors.push(colors[i].clone());\n      }\n      const faces = source.faces;\n      for (let i = 0, il = faces.length; i < il; i++) {\n        this.faces.push(faces[i].clone());\n      }\n      for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n        const faceVertexUvs = source.faceVertexUvs[i];\n        if (this.faceVertexUvs[i] === void 0) {\n          this.faceVertexUvs[i] = [];\n        }\n        for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n          const uvs = faceVertexUvs[j],\n            uvsCopy = [];\n          for (let k = 0, kl = uvs.length; k < kl; k++) {\n            const uv = uvs[k];\n            uvsCopy.push(uv.clone());\n          }\n          this.faceVertexUvs[i].push(uvsCopy);\n        }\n      }\n      const morphTargets = source.morphTargets;\n      for (let i = 0, il = morphTargets.length; i < il; i++) {\n        const morphTarget = {};\n        morphTarget.name = morphTargets[i].name;\n        if (morphTargets[i].vertices !== void 0) {\n          morphTarget.vertices = [];\n          for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n          }\n        }\n        if (morphTargets[i].normals !== void 0) {\n          morphTarget.normals = [];\n          for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n            morphTarget.normals.push(morphTargets[i].normals[j].clone());\n          }\n        }\n        this.morphTargets.push(morphTarget);\n      }\n      const morphNormals = source.morphNormals;\n      for (let i = 0, il = morphNormals.length; i < il; i++) {\n        const morphNormal = {};\n        if (morphNormals[i].vertexNormals !== void 0) {\n          morphNormal.vertexNormals = [];\n          for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n            const srcVertexNormal = morphNormals[i].vertexNormals[j];\n            const destVertexNormal = {};\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n            morphNormal.vertexNormals.push(destVertexNormal);\n          }\n        }\n        if (morphNormals[i].faceNormals !== void 0) {\n          morphNormal.faceNormals = [];\n          for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n          }\n        }\n        this.morphNormals.push(morphNormal);\n      }\n      const skinWeights = source.skinWeights;\n      for (let i = 0, il = skinWeights.length; i < il; i++) {\n        this.skinWeights.push(skinWeights[i].clone());\n      }\n      const skinIndices = source.skinIndices;\n      for (let i = 0, il = skinIndices.length; i < il; i++) {\n        this.skinIndices.push(skinIndices[i].clone());\n      }\n      const lineDistances = source.lineDistances;\n      for (let i = 0, il = lineDistances.length; i < il; i++) {\n        this.lineDistances.push(lineDistances[i]);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n      return this;\n    }\n    toBufferGeometry() {\n      const geometry = new DirectGeometry().fromGeometry(this);\n      const buffergeometry = new BufferGeometry();\n      const positions = new Float32Array(geometry.vertices.length * 3);\n      buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n      if (geometry.normals.length > 0) {\n        const normals = new Float32Array(geometry.normals.length * 3);\n        buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n      }\n      if (geometry.colors.length > 0) {\n        const colors = new Float32Array(geometry.colors.length * 3);\n        buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n      }\n      if (geometry.uvs.length > 0) {\n        const uvs = new Float32Array(geometry.uvs.length * 2);\n        buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n      }\n      if (geometry.uvs2.length > 0) {\n        const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n        buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n      }\n      buffergeometry.groups = geometry.groups;\n      for (let name in geometry.morphTargets) {\n        const array = [];\n        const morphTargets = geometry.morphTargets[name];\n        for (let i = 0, l = morphTargets.length; i < l; i++) {\n          const morphTarget = morphTargets[i];\n          const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n          attribute.name = morphTarget.name;\n          array.push(attribute.copyVector3sArray(morphTarget.data));\n        }\n        buffergeometry.morphAttributes[name] = array;\n      }\n      if (geometry.skinIndices.length > 0) {\n        const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n        buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n      }\n      if (geometry.skinWeights.length > 0) {\n        const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n        buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n      return buffergeometry;\n    }\n    computeTangents() {\n      console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n    }\n    computeLineDistances() {\n      console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n    }\n    applyMatrix(matrix) {\n      console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n      return this.applyMatrix4(matrix);\n    }\n    dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }\n  return Geometry2;\n})();\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport { Face3, Geometry };\n//# sourceMappingURL=Geometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}