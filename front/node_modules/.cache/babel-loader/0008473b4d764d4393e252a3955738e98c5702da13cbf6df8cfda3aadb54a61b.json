{"ast":null,"code":"import { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter, BufferAttribute } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\nexport class MeshBVHUniformStruct {\n  constructor() {\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this._cachedIndexAttr = null;\n    this.index.overrideItemSize = 3;\n  }\n  updateFrom(bvh) {\n    const {\n      geometry\n    } = bvh;\n    bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n    this.position.updateFrom(geometry.attributes.position);\n\n    // dereference a new index attribute if we're using indirect storage\n    if (bvh.indirect) {\n      const indirectBuffer = bvh._indirectBuffer;\n      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {\n        if (geometry.index) {\n          this._cachedIndexAttr = geometry.index.clone();\n        } else {\n          const array = getIndexArray(getVertexCount(geometry));\n          this._cachedIndexAttr = new BufferAttribute(array, 1, false);\n        }\n      }\n      dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);\n      this.index.updateFrom(this._cachedIndexAttr);\n    } else {\n      this.index.updateFrom(geometry.index);\n    }\n  }\n  dispose() {\n    const {\n      index,\n      position,\n      bvhBounds,\n      bvhContents\n    } = this;\n    if (index) index.dispose();\n    if (position) position.dispose();\n    if (bvhBounds) bvhBounds.dispose();\n    if (bvhContents) bvhContents.dispose();\n  }\n}\nfunction dereferenceIndex(geometry, indirectBuffer, target) {\n  const unpacked = target.array;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    const i3 = 3 * i;\n    const v3 = 3 * indirectBuffer[i];\n    for (let c = 0; c < 3; c++) {\n      unpacked[i3 + c] = indexArray ? indexArray[v3 + c] : v3 + c;\n    }\n  }\n}\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  const roots = bvh._roots;\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n  const root = roots[0];\n  const uint16Array = new Uint16Array(root);\n  const uint32Array = new Uint32Array(root);\n  const float32Array = new Float32Array(root);\n\n  // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n  const nodeCount = root.byteLength / BYTES_PER_NODE;\n  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeIndex32 = i * BYTES_PER_NODE / 4;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n    for (let b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      const count = COUNT(nodeIndex16, uint16Array);\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      const rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  boundsTexture.dispose();\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n  contentsTexture.dispose();\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}